(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{YSjP:function(e,n){e.exports=[{file:"README.md",lang:"md",section:"default",code:'<h1><a id="control-panel" class="anchor" href="#control-panel"><span class="header-link"></span></a>Control Panel</h1><p>To create a dynamic form we need an instance of a model which we\nbind to the <code>[model]</code> attribute.</p>\n<pre class="lang-html"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">dynamic-form</span> [<span class="hljs-attr">model</span>]=<span class="hljs-string">"model"</span>&gt;</span>\n</code></pre>\n<p>The dynamic form component will use the model to create a <code>FormGroup</code>\ninstance and render that instance.</p>\n<p>The <strong>model</strong> and the <strong>form group</strong> represent the same entity, the user\ncan edit the form and once done we commit the changes done in the form\nonto the model.</p>\n<p>The model and the form group are linked, an operation on one requires\nthe other and there are tasks that apply on both.</p>\n<p>We need a container we can put them both in and let the container\nmanage them internally and expose an interface for us, a <strong>control\npanel</strong></p>\n<h2><a id="tdmmodelform" class="anchor" href="#tdmmodelform"><span class="header-link"></span></a>TDMModelForm</h2><p>When we assign an instance of a model to a dynamic form component the\ncomponent create&#39;s smart container that handle&#39;s all the operations\nrequired from a model and a form group, that container is <code>TDMModelForm</code></p>\n<div class="info">\nMost of the topics we are about to cover relate to topics not yet\ncovered by the tutorial, mostly around complex data structures.\n</div>\n\n<h3><a id="committomodel" class="anchor" href="#committomodel"><span class="header-link"></span></a>commitToModel</h3><p>Taking the value of the form and merging the changes onto the model.</p>\n<p>This topic was covered in the previous chapter.</p>\n<h3><a id="read-write" class="anchor" href="#read-write"><span class="header-link"></span></a>Read/Write</h3><p>Using <code>getValue</code> and <code>setValue</code> we can read/write values from/to the\n<strong>form</strong>.</p>\n<p>Using <code>getValueModel</code> we can read values from the <strong>model</strong>.</p>\n<p>All read/write methods support deep paths using dot notation strings\nor deep path arrays.</p>\n<pre class="lang-ts"><code class="lang-ts">getValueModel(path: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; | <span class="hljs-built_in">string</span>): <span class="hljs-built_in">any</span> | <span class="hljs-literal">null</span>\n</code></pre>\n<p>Angular forms comes with built-in support for deep paths using the\nsame API, in-fact the library mimic the API. This means <code>getValue</code> and\n<code>setValue</code> are just proxies.</p>\n<p><code>getValueModel</code> add&#39;s value because it aligns the API allowing easy\naccess to values on the model based on path&#39;s from the form.</p>\n<div class="alert">\nRead/Write operations are common when working with complex data structure\nsuch as Array&#39;s or nested objects. We will revisit them in the relevant\nchapters. \n</div>\n\n<h3><a id="sync-reset" class="anchor" href="#sync-reset"><span class="header-link"></span></a>Sync/Reset</h3><p>The <code>sync</code> and <code>reset</code> methods are self explaining, they both\nrequire the model and the form.</p>\n<h3><a id="addcontrol-removecontrol" class="anchor" href="#addcontrol-removecontrol"><span class="header-link"></span></a>addControl / removeControl</h3><p>Adding and removing controls are operations performed on forms with\narrays, these are <code>FormArray</code> controls.</p>\n<p>When we want to add an item to a <code>FormArray</code> we can not added a new\ninstance of the item, we need to add the form control that represent\nthat item.</p>\n<p>For example, a model with the property <strong>names</strong> of type <code>string[]</code>, if\nwe want to push a new string to the <strong>names</strong> property we can not use\nthe model (<code>model.push(&#39;new name&#39;)</code>) instead we need to push a new\n<code>FormControl</code> to the <code>FormArray</code> that represent <strong>names</strong>.</p>\n<p>What if <strong>names</strong> is not <code>string[]</code> but an array of a complex type, a\nnested model. Now we can&#39;t push a <code>FormControl</code> we need a <code>FormGroup</code>.</p>\n<p>To simplify the process the <code>addControl</code> will do all the work for us</p>\n<pre class="lang-ts"><code class="lang-ts">appendControl(path: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; | <span class="hljs-built_in">string</span>, value?: <span class="hljs-built_in">any</span>): FormGroup | FormControl\n</code></pre>\n<p>We just need to provide the full path and a new form control is added.\nIf we provide a <strong>value</strong> it will be used to populate the new control.</p>\n<p><code>removeControl</code> works the same</p>\n<pre class="lang-ts"><code class="lang-ts">removeControl(path: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; | <span class="hljs-built_in">string</span>, query: <span class="hljs-built_in">number</span> | AbstractControl): AbstractControl | <span class="hljs-literal">undefined</span>\n</code></pre>\n<p>Here we also need a <strong>query</strong> which is the index we want to remove at\nor a control which the method will use to resolve the index to remove.</p>\n<div class="alert">\nThe <strong>path</strong> in the add/remove methods must point to an instance of <code>FormArray</code>\n</div>\n\n<h2><a id="createchildform" class="anchor" href="#createchildform"><span class="header-link"></span></a>createChildForm</h2><pre class="lang-ts"><code class="lang-ts">createChildForm&lt;Z = <span class="hljs-built_in">any</span>&gt;(path: <span class="hljs-built_in">Array</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; | <span class="hljs-built_in">string</span>, model?: Z): TDMModelForm&lt;Z&gt; {\n</code></pre>\n<p><code>createChildForm</code> is a method that returns a new instance of <code>TDMModelForm</code>\nbased on the type the <strong>path</strong> points at.</p>\n<p>The type must be a <em>known model</em> and explicitly declared as a <code>childForm</code></p>\n<p>The optional <strong>model</strong> parameter is used to populate the form, this is\nwhere we need to use <code>getValueModel</code></p>\n<div class="alert">\n<code>createChildForm</code> is used when working with complex data structures,\nchild forms in particular. \n</div>'}]}}]);