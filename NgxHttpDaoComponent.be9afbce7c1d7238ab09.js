(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{I1FV:function(s,n){s.exports=[{file:"README.md",lang:"md",section:"PART-1",code:'<h1><a id="data-access-object" class="anchor" href="#data-access-object"><span class="header-link"></span></a>Data Access Object</h1><p>The data access object is a famous design pattern for handling data\nmodels.</p>\n<p>It is the API that maps an instance of a resource to an action and sends\nthem to the <strong>Adapter</strong> for execution.</p>\n<p>Let&#39;s jump straight into a demo, click on the <strong>play</strong> button:</p>\n',title:"DAO"},{file:"README.md",lang:"md",section:"PART-2",code:'<p><br>\nLet&#39;s describe what is happening in the code:</p>\n<ol>\n<li>We create a data access object (DAO) for the <code>Customer</code> resource.</li>\n<li>We use the DAO to retrieve (GET) a customer with a specific identifier.</li>\n<li>With the customer we got, we update some values and call replace (PATCH) to\npersist the changes in the server.</li>\n<li>We now query (GET) the entire collection (table) of customers, we\nexpect to get back an array of <code>Customer</code> instances.</li>\n<li>Doing a useless test to check our customer exists in the list and\nit has the updated values. </li>\n</ol>\n<div class="info">\nWe are using <strong>async/await</strong>, this helps to simplify the code,\nespecially when the example has a complex flow with multiple requests.\n<br> \n<br> \nIf you are not familiar with <strong>async/await</strong>, we recommend catching up.\n<br>\nFor the time being, when you see an <strong>await</strong> token remember this:\n<br> \n<br>\nThe entire expression to the right (of await) returns a promise.\n<br>\nThe entire expression to the left is the value <strong>resolved</strong> from the\npromise.\n<br> \n<br>\nIn between magic happens and an invisible <strong>then</strong> handler was registered.\n<br> \n<br>\nThe program will pause until the promise resolved, then set it to the\nvalue on the left an continue. No callback clutter.\n</div>\n\n<h2><a id="getting-the-dao" class="anchor" href="#getting-the-dao"><span class="header-link"></span></a>Getting the DAO</h2><p>The DAO is available through angular&#39;s DI, ready to use.</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">import</span> { NgDAO } <span class="hljs-keyword">from</span> <span class="hljs-string">\'@tdm/ngx-http-client\'</span>;\n\n<span class="hljs-meta">@Component</span>({\n  selector: <span class="hljs-string">\'ngx-http-dao\'</span>,\n  templateUrl: <span class="hljs-string">\'./dao.component.html\'</span>,\n  styleUrls: [ <span class="hljs-string">\'./dao.component.scss\'</span> ],\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> DaoComponent {\n  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">ngDAO: NgDAO</span>) {\n\n  }\n}\n</code></pre>\n<h2><a id="dap-api" class="anchor" href="#dap-api"><span class="header-link"></span></a>DAP API</h2><p>Let&#39;s look at the DAO API:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> HttpDao&lt;T&gt; {\n  query: <span class="hljs-function">(<span class="hljs-params">options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T[]&gt;;\n  findAll: <span class="hljs-function">(<span class="hljs-params">options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T[]&gt;; alias <span class="hljs-keyword">for</span> query\n\n  findById: <span class="hljs-function">(<span class="hljs-params">id: IdentityValueType, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;;\n\n  find: <span class="hljs-function">(<span class="hljs-params">options: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;;\n  findOne: <span class="hljs-function">(<span class="hljs-params">options: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T&gt;; <span class="hljs-comment">// alias for find</span>\n\n  create: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  update: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  replace: <span class="hljs-function">(<span class="hljs-params">data: T | Partial&lt;T&gt;, options?: HttpActionOptions</span>) =&gt;</span> <span class="hljs-built_in">Promise</span>&lt;T | <span class="hljs-built_in">void</span>&gt;;\n\n  remove: <span class="hljs-function">(<span class="hljs-params"> (<span class="hljs-params">id: IdentityValueType | T, options?: HttpActionOptions</span>) =&gt; <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; </span>);\n}</span>\n</code></pre>\n<p>These are pretty straight forward, they represent the DAO interface\nfor the <code>HttpResource</code> adapter.</p>\n<p>Adjacent methods with no empty line between them are alias methods, they\nare identical.</p>\n<h3><a id="response" class="anchor" href="#response"><span class="header-link"></span></a>Response</h3><p>The DAO API is promise based, every call returns a <code>Promise</code> of the\nresult.</p>\n<ul>\n<li><p>When the remote server returns an <strong>object</strong>, it is assumed to be in\nthe shape and structure of the resource and the library will\ndeserialize it into a new instance and resolve it.</p>\n</li>\n<li><p>When the server returns a <strong>primitive</strong> (string, number, null, etc...)\nthe library will return the primitive value (no deserialization)</p>\n<p>An example is <strong>POST / PUT / PATCH / DELETE</strong> calls that usually\nreturn null.</p>\n</li>\n</ul>\n<p>When an exception is throw, we can catch it by registering a <code>catch</code>\nhandler.</p>\n<h2><a id="additional-info" class="anchor" href="#additional-info"><span class="header-link"></span></a>Additional info</h2><ul>\n<li><p>Post processing, transforming, or changing the process and/or\nresponse is possible by extending existing or creating new <strong>Actions</strong>\nwhich we will cover in the future. </p>\n</li>\n<li><p>The promise API is simple, the life-cycle is a simple start and an\nend, which is enough for most use-cases.<br>Some scenarios require access to the internal life-cycle hooks, such\nas progress notification, cancellation and more...</p>\n<p>We can access these notification through the resource control, which\nis covered in the next chapter. </p>\n</li>\n</ul>\n<h3><a id="actions" class="anchor" href="#actions"><span class="header-link"></span></a>Actions</h3><p>An <strong>Action</strong> is a definition of an operation.</p>\n<p>It is similar to angular&#39;s <code>HttpClient</code> where call requires a\nconfiguration. The url, http verb, headers, params, etc...</p>\n<p>In <code>HttpClient</code> each call requires a configuration but <strong>Actions</strong> are\nstatic, they define an action for the resource that does not change.</p>\n<p>You can think of an action as a factory function. When you have the\nsame GET call for all of your models you will probably use a factory\nfunction to execute the <code>HttpClient</code> with some parameters fixed.</p>\n<p>The DAO exposes the actions as methods. Each methods is bound to and\naction and when invoked will bundle the action and the instance and\nsend them to the adapter for processing.</p>\n<div class="info">\nWe will explore <strong>Actions</strong> in-depth when we cover custom actions. Right\nnow, the actions we use come with the library.\n</div>\n\n<h2><a id="dao-and-active-record" class="anchor" href="#dao-and-active-record"><span class="header-link"></span></a>DAO and Active Record</h2><p>The <strong>ActiveRecord</strong> pattern takes a different approach, each call\nreturns an instance of the model, rather then a <code>Promise</code>.</p>\n<p>The operation is still async, the data will be assigned when it arrive.</p>\n<p>Active record also add actions that we can invoke from the instance\nitself, these will return the <strong>same</strong> instance, updating the instance\nwhen the data arrive.</p>\n<p>When we return an instance we have no idea what happens, when something\narrives and if we had an error in between, we use the resource control\nfor that.</p>\n<div class="alert">\n<code>@tdm/data</code> comes with an abstract DAO that all adapters must implement,\nsome adapters might extend it.\n</div> ',title:"DAO"},{file:"dao.component.ts",lang:"ts",section:"code",code:'<span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> ngDao: NgDAO</span>) {\r\n\r\n  <span class="hljs-keyword">const</span> customerDao = ngDao.get(Customer);\r\n  <span class="hljs-keyword">let</span> customer = <span class="hljs-keyword">await</span> customerDao.findById(<span class="hljs-string">\'ALFKI\'</span>);\r\n\r\n  customer.CompanyName = <span class="hljs-string">\'Microsoft\'</span>;\r\n  customer.City = <span class="hljs-string">\'San Francisco\'</span>;\r\n  <span class="hljs-keyword">await</span> customerDao.replace(customer);\r\n\r\n  <span class="hljs-keyword">const</span> customers = <span class="hljs-keyword">await</span> customerDao.query();\r\n\r\n  customer = customers.find(<span class="hljs-function"><span class="hljs-params">c</span> =&gt;</span> c.CustomerID === <span class="hljs-string">\'ALFKI\'</span>);\r\n  <span class="hljs-keyword">if</span> (!customer || customer.CompanyName !== <span class="hljs-string">\'Microsoft\'</span> || customer.City !== <span class="hljs-string">\'San Francisco\'</span>) {\r\n    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">\'Invalid demo!!!\'</span>);\r\n  }\r\n\r\n}\r\n'}]}}]);