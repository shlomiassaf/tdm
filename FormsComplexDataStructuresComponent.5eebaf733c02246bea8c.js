(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{"8bGD":function(s,n){s.exports=[{file:"README.md",lang:"md",section:"default",code:'<h3><a id="definition" class="anchor" href="#definition"><span class="header-link"></span></a>Definition</h3><p>A <strong>Complex Data Structure</strong> refers to all properties in a model,\ndecorated by <code>@FormProp</code>, with a type that is not <strong>primitive</strong>.</p>\n<div class="alert">\nThe JavaScript standard defines 7 data types. 6 primitive types and the\n<code>Object</code> type.\n</div>\n\n<p>The type of a property in a model / class can be a:</p>\n<ol>\n<li>Primitive</li>\n<li>Class of a <em>known model</em></li>\n<li>Interface / Type / Class of an unknown model</li>\n<li>Array of 1-3 </li>\n</ol>\n<div class="info">\nA <em>known model</em> is a class decorated with <code>@FormModel</code>. The class is\n&quot;known&quot; to the library.\n</div>\n\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-meta">@Model</span>({\n  form: <span class="hljs-literal">true</span>\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Hero {\n  Prop1: <span class="hljs-built_in">number</span>;\n  Prop2: Hero;\n  Prop3: { value: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> };\n  Prop4_1: <span class="hljs-built_in">number</span>[];\n  Prop4_2: Hero[];\n  Prop4_3: { value: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> }[];\n}\n</code></pre>\n<p>In the example above, <code>Prop1</code> is not a complex data structure.</p>\n<h3><a id="what-is-it-" class="anchor" href="#what-is-it-"><span class="header-link"></span></a>What is it?</h3><p>A <strong>Complex Data Structure</strong> represents a type.</p>\n<p>The resolved type of a <strong>Complex Data Structure</strong> is the combination of\nthe annotated type and the metadata provided for each <code>@FormProp</code>.</p>\n<p>The annotated type and the resolved <strong>Complex Data Structure</strong> type\nusually match but not always.</p>\n<h3><a id="what-does-it-mean-" class="anchor" href="#what-does-it-mean-"><span class="header-link"></span></a>What does it mean?</h3><p>It means that for a property that is not a primitive we can have 2\ndifferent structures which we use together, the extra structure is used\nto describe a different UI layout.</p>\n<p>In simple words, a the form instance will always represent the model&#39;s\nstructure. The rendered form will represent <strong>Complex Data Structure</strong>.</p>\n<h2><a id="complex-data-structures" class="anchor" href="#complex-data-structures"><span class="header-link"></span></a>Complex Data structures</h2><p><code>@angular/forms</code> has 3 fundamental building blocks used to define forms:\n<code>FormControl</code>, <code>FormGroup</code> and <code>FormArray</code>.</p>\n<p>When we create a dynamic form for the model <code>Hero</code> the library will take\nall the properties in the <code>Hero</code> class that are decorated with\n<code>@FormProp</code> and create a form control for it, one of the 3 building\nblocks, using the metadata defined.</p>\n<p><strong>For each property we have a form control and a runtime type.</strong></p>\n<p>Can we conclude that a property of a complex data type always create a\ncomplex form control? </p>\n<p>No, let&#39;s see why.</p>\n<h3><a id="primitive-amp-complex-form-controls" class="anchor" href="#primitive-amp-complex-form-controls"><span class="header-link"></span></a>Primitive &amp; Complex form controls</h3><p>Angular forms doesn&#39;t explicitly recognize the terms <code>primitive</code> and\n<code>complex</code> but we can try:</p>\n<ul>\n<li><code>FormControl</code> is always primitive</li>\n<li><code>FormGroup</code> is always complex</li>\n<li><code>FormArray</code> is primitive or complex based on the type it contains.</li>\n</ul>\n<p>These definitions are used to drive the UI, how the layout is set and\nhow a control is going to display.</p>\n<p>When creating a form control for a given property the library will use\nthe type along with other metadata provided to create the control.</p>\n<p>It means that a property of a complex type can be a <code>FormControl</code>.</p>\n<h3><a id="complex-data-structure" class="anchor" href="#complex-data-structure"><span class="header-link"></span></a>Complex Data Structure</h3><p>Complex data structure we refer to the  </p>\n<p> the data type of the value attached to a control\ndoes not define </p>\n<p>When we refer to a <strong>complex data structure</strong> we refer data type that\nextends the <code>Object</code> data type.</p>\n<p>A primitive type can never become a <strong>complex data structure*</strong> but\nan <code>Object</code> can </p>\n'},{file:"SIMPLE.md",lang:"md",section:"default",code:'<h1><a id="complex-data-structures" class="anchor" href="#complex-data-structures"><span class="header-link"></span></a>Complex data structures</h1><p>Let&#39;s examine the <code>Hero</code> model, there is something common to all\nproperties, what is it:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">class</span> Hero {\n  id: <span class="hljs-built_in">number</span>;\n  name: <span class="hljs-built_in">string</span>;\n  hasTracking: <span class="hljs-built_in">boolean</span>;\n  doubleAgent: <span class="hljs-built_in">boolean</span>;\n  bmi: <span class="hljs-built_in">number</span>;\n  superPower: <span class="hljs-string">\'selfHealing\'</span> | <span class="hljs-string">\'flying\'</span> | <span class="hljs-string">\'cloaking\'</span> | <span class="hljs-string">\'cloning\'</span> | <span class="hljs-string">\'invisibility\'</span>;\n}\n</code></pre>\n<p>The type off all properties is one of <code>boolean</code>, <code>number</code> or <code>string</code>.</p>\n<p>These are all <strong>primitive</strong> types.</p>\n<div class="alert">\nThe JavaScript standard defines 7 data types. 6 primitive types and the\n<code>Object</code> type.\n</div>\n\n<p>The common to all properties is that they are all primitives, we call\nthis model a flat model, it has a depth of 1.</p>\n<p>Here is how an instance might look like:</p>\n<pre class="lang-js"><code class="lang-js">{\n  <span class="hljs-attr">id</span>: <span class="hljs-string">"99"</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Super Man"</span>,\n  <span class="hljs-attr">hasTracking</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">doubleAgent</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">bmi</span>: <span class="hljs-number">18</span>,\n  <span class="hljs-attr">superPower</span>: <span class="hljs-string">"flying"</span>\n}\n</code></pre>\n<p>We can imagine how a form will display, labels next to values, flat\nmodels are easy to display.</p>\n<h2><a id="adding-depth" class="anchor" href="#adding-depth"><span class="header-link"></span></a>Adding depth</h2><p>A <strong>non-primitive</strong> type is any type that extends <code>Object</code>, these are\nall types except the 6 primitive types defined by the standard.</p>\n<p>Within all <strong>non-primitive</strong> types we have 2 sub-groups: <code>Array</code> \nand <code>Object</code>.</p>\n<p>Let&#39;s see some examples for depth:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-meta">@Model</span>({\n  form: <span class="hljs-literal">true</span>\n})\n<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Hero {  \n  Prop2: Hero;\n  Prop3: { value: <span class="hljs-built_in">string</span>; id: <span class="hljs-built_in">number</span> };\n  Prop4_1: <span class="hljs-built_in">number</span>[];\n  Prop4_2: Hero[];\n  Prop4_3: {\n    value: <span class="hljs-built_in">string</span>;\n    id: <span class="hljs-built_in">number</span>,\n    more: {\n      deep: {\n        sea: <span class="hljs-built_in">boolean</span>\n      }\n    }\n  }[];\n}\n</code></pre>\n<div class="info">\n  1. <code>Object</code> is the base type for all non primitive types, <code>Hero</code> is an\n  object.\n  <br>\n  <br>\n  2. <code>Array</code> is therefor also an <code>Object</code> but it is a special case,\n  handled different.\n</div>\n\n<p>Let&#39;s review how to work with both types, in the end we will inspect\nhow to perform operations required when working with complex data\nstructures.</p>\n<h2><a id="object" class="anchor" href="#object"><span class="header-link"></span></a>Object</h2><p>Our <code>Hero</code> model is an object with all properties being primitives.</p>\n<pre class="lang-js"><code class="lang-js">{\n  <span class="hljs-attr">id</span>: <span class="hljs-string">"99"</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Super Man"</span>,\n  <span class="hljs-attr">hasTracking</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">doubleAgent</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">bmi</span>: <span class="hljs-number">18</span>,\n  <span class="hljs-attr">superPower</span>: <span class="hljs-string">"flying"</span>\n}\n</code></pre>\n<p>It is also known as a <em>document</em>.</p>\n<p>Once we add properties that are objects we create <em>embedded documents</em></p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">interface</span> Nemesis {\n  id: <span class="hljs-built_in">number</span>;\n  name: <span class="hljs-built_in">string</span>;\n}\n\n<span class="hljs-keyword">class</span> Hero {\n  ...\n\n  nemesis: Nemesis;\n}\n</code></pre>\n<pre class="lang-js"><code class="lang-js">{\n  <span class="hljs-attr">id</span>: <span class="hljs-number">99</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Super Man"</span>,\n  <span class="hljs-attr">hasTracking</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">doubleAgent</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">bmi</span>: <span class="hljs-number">18</span>,\n  <span class="hljs-attr">superPower</span>: <span class="hljs-string">"flying"</span>,\n  <span class="hljs-attr">nemesis</span>: {\n    <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,\n    <span class="hljs-attr">name</span>: <span class="hljs-string">"Bat Man"</span>\n  }\n}\n</code></pre>\n<p>How do we display <code>nemesis</code>?</p>\n<p>If the renderer we use has a <em>visual type</em> for this specific type, easy:</p>\n<pre class="lang-ts"><code class="lang-ts">@Model({\n  form: true\n})\nclass Hero {\n  @Prop({\n    form: {\n      render: {\n        vType: &#39;Nemesis`\n      }\n    }\n  })\n  nemesis: Nemesis;\n}\n</code></pre>\n<p>But that&#39;s very specific, renderer&#39;s will usually handle primitives.</p>\n<p>We have 2 options:</p>\n<ol>\n<li>Using a child form</li>\n<li>Flattening <code>nemesis</code></li>\n</ol>\n<h3><a id="1-using-a-child-form" class="anchor" href="#1-using-a-child-form"><span class="header-link"></span></a>1. Using a child form</h3><p>A Child form is how we tell the library that the property type is a <strong>\nknown model</strong>. The library will treat this property as a form and the\ndisplay depends on the renderer we use.</p>\n<p>There are a lot of ways for renderer to implement child forms. Dialog,\ninline, projection, etc...</p>\n<div class="info">\nA <strong>known model</strong> is a class decorated with <code>@FormModel</code>. The class is\n&quot;known&quot; to the library.\n<br>\n<br>\n<code>Hero</code> is a known model.\n</div>\n\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-meta">@Model</span>({\n  form: <span class="hljs-literal">true</span>\n})\n<span class="hljs-keyword">class</span> Hero {\n  <span class="hljs-meta">@Prop</span>({\n    form: {\n      childForm: <span class="hljs-literal">true</span>\n    }\n  })\n  nemesis: Nemesis;\n}\n</code></pre>\n<div class="info">\nNote that <code>childForm</code> is set on the metadata but not in the <code>render</code>\nobject, it is a logical definition not a visual definition.\n<br>\nVisual definitions are handled by the <strong>renderer</strong>\n</div>\n\n<div class="alert">\nSetting <code>childForm: true</code> is valid only when the type of the property\nis a <strong>known model</strong>.\n</div>\n\n<p><a class="tdm-anchor-trap" href="../child-form">Read more...</a></p>\n<h3><a id="2-flattening-code-nemesis-code-" class="anchor" href="#2-flattening-code-nemesis-code-"><span class="header-link"></span></a>2. Flattening <code>nemesis</code></h3><p>We&#39;ve opened this chapter by saying the <code>Hero</code> is a flat model, what if\nwe can define how to flatten the <code>nemesis</code> property so all of it&#39;s\nproperties will be on the <code>Hero</code> class?</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">class</span> Hero {\n  ...\n\n  id: <span class="hljs-built_in">number</span>;\n  name: <span class="hljs-built_in">string</span>;\n}\n</code></pre>\n<p>We can, it is called flattening and we do it by providing a flattening\ndefinition:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-meta">@Model</span>({\n  form: <span class="hljs-literal">true</span>\n})\n<span class="hljs-keyword">class</span> Hero {\n  <span class="hljs-meta">@Prop</span>({\n    form: {\n      flatten: {\n        id: {\n          required: <span class="hljs-literal">true</span>,\n          render: {\n            vType: <span class="hljs-string">\'number\'</span>,\n            label: <span class="hljs-string">\'Nemesis ID\'</span>,\n          }\n        },\n        name: {\n          required: <span class="hljs-literal">true</span>,\n          render: {\n            vType: <span class="hljs-string">\'text\'</span>,\n            label: <span class="hljs-string">\'Nemesis Name\'</span>,\n          }\n        }\n      }              \n    }\n  })\n  nemesis: Nemesis;\n}\n</code></pre>\n<p>It might look odd, we are flattening out the <code>id</code> and <code>name</code> properties\nfrom <code>Nemesis</code> which already exist in <code>Hero</code>. There is no issue because\nthis is not a <strong>structural</strong> change in the model but only in the display.\nThe form remains an identical representation of the model the only thing\nthat change is the order and structure of the control we renders.</p>\n<p>Flattening definitions work on both known and unknown models. They are\nnot limited in depth (i.e. you can define nested flattening definitions)</p>\n<p>The actual structure of the model we work with and the structure of the\nform:</p>\n<pre class="lang-js"><code class="lang-js">{\n  <span class="hljs-attr">id</span>: <span class="hljs-number">99</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Super Man"</span>,\n  <span class="hljs-attr">hasTracking</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">doubleAgent</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">bmi</span>: <span class="hljs-number">18</span>,\n  <span class="hljs-attr">superPower</span>: <span class="hljs-string">"flying"</span>,\n  <span class="hljs-attr">nemesis</span>: {\n    <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,\n    <span class="hljs-attr">name</span>: <span class="hljs-string">"Bat Man"</span>\n  }\n}\n</code></pre>\n<p>However, the way they are presented:</p>\n<pre class="lang-js"><code class="lang-js">{\n  <span class="hljs-attr">id</span>: <span class="hljs-number">99</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Super Man"</span>,\n  <span class="hljs-attr">hasTracking</span>: <span class="hljs-literal">false</span>,\n  <span class="hljs-attr">doubleAgent</span>: <span class="hljs-literal">true</span>,\n  <span class="hljs-attr">bmi</span>: <span class="hljs-number">18</span>,\n  <span class="hljs-attr">superPower</span>: <span class="hljs-string">"flying"</span>,\n\n  <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,\n  <span class="hljs-attr">name</span>: <span class="hljs-string">"Bat Man"</span>\n}\n</code></pre>\n<p>The user will see the labels, not the property names.\n<a class="tdm-anchor-trap" href="../flattening">Read more...</a></p>\n<h2><a id="arrays" class="anchor" href="#arrays"><span class="header-link"></span></a>Arrays</h2><p>Array&#39;s are unique, they create a structure that an <code>Object</code> can not\nrepresent directly. An indexed list.</p>\n<p>Let change the <code>nemesis</code> for the <code>Hero</code> so we can set multiple rivals,\na list of <code>Nemesis</code>:</p>\n<pre class="lang-ts"><code class="lang-ts"><span class="hljs-keyword">class</span> Hero {\n  ...\n\n  nemesis: <span class="hljs-built_in">Array</span>&lt;Nemesis&gt;;\n}\n</code></pre>\n<p>When we look at the type: <code>Array&lt;Nemesis&gt;</code>, Array of T. The type of an\nArray is bound to the type of the children it contains.</p>\n<p>Working with array&#39;s does not require special metadata definitions,\nthe definitions set on <code>@FormProp</code> are those you would define on the\ntype the array is bound to. Almost like the array is not there.</p>\n<h4><a id="array-of-primitive" class="anchor" href="#array-of-primitive"><span class="header-link"></span></a>Array of primitive</h4><p>When an array is bound to a primitive the metadata definitions are those\nof the primitive, the array is only used in the type annotation.</p>\n<h4><a id="array-of-code-object-code-" class="anchor" href="#array-of-code-object-code-"><span class="header-link"></span></a>Array of <code>Object</code></h4><p>When the array is bound to a complex type the definitions are those\nof the complex type an so, all the options we covered above are valid.</p>\n<p>Yes, you can define an flattening definition for the interface <code>Nemesis</code>\napplied for on a list.</p>\n<h4><a id="working-with-arrays" class="anchor" href="#working-with-arrays"><span class="header-link"></span></a>Working with arrays</h4><p>Working with array&#39;s it is best to keep things simple.</p>\n<p>Simple means array of primitives.</p>\n<p>When in need to show an array of complex types prefer <code>childForm</code> while\nshowing a list of models and editing each externally.</p>\n<div class="alert">\nAvoid flattening declaration over an array.\n<br>\n<br>\nUnless you are building you&#39;r own custom renderer and you are prepared\nfor surprises. This will not end well.\n</div>\n\n<p><a class="tdm-anchor-trap" href="../arrays">Read more...</a></p>\n<h2><a id="tools" class="anchor" href="#tools"><span class="header-link"></span></a>Tools</h2><p>Working with flat does&#39;nt involve operations on the structure of the\nmodel.</p>\n<p>Working with complex data types does. Adding and/or removing items\nfrom an array, assigning a form control to a <code>childForm</code> property...</p>\n<p>The library provide the tools to simplify the process, we covered\nthem in the <strong>Control Panel</strong> chapter, using <code>TDMModelForm</code>.</p>\n<p>It is a good time to revisit that chapter. </p>\n'}]}}]);